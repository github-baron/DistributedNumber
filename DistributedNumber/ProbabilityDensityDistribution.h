/*
 * 
 * MIT License
 *  
 * Copyright (c) 2020 Michael von Mengershausen
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 * 
 */

/**
 * \mainpage [ProbabilityDensityDistribution Library]
 * ProbabilityDensityDistribution library is an API for 1D random variables. 
 * It offers:
 * - simple generation of a distribution of a random variable 
 *   - adding @ref def-distri-point "points" as a tuple of variable value and its probability denisty (or any other parameter representing the occurrence).
 *   - the normalization is done automatically. Hence, the default representation of the parameter of occurrence is probability density.
 *   - the original parameter of occurrence can be restored by CProbabilityDensityDistribution::DeNormalize.<br> This is helpful if the distribution is generated by counting the number of occurences of a given value.
 * - quasi continous handling:...
 *    - ... interpolating distribution values for any given variable
 *    - ... calculating any n'th order weighted integral of this distribution
 *    - ... calculating intervals for a given coverage
 * - supports arithmetic operations of random variable :
 *   - ::operator+(CProbabilityDensityDistribution&)
 *   - ::operator-(CProbabilityDensityDistribution&) 
 *   - ::operator*(CProbabilityDensityDistribution&)
 *   - ::operator/(CProbabilityDensityDistribution&) 

/**
 * @brief This class represents a probability density distribution. 
 * It offers :
 * - handling of probability:
 *     - adding non-probability density \ref def-distri-value "values" is possible (e.g. countings of the occurrence of a variable)
 *     - normalization will be done when needed (e.g. query for a distribution value will return a probability density value)
 *     - the query for 
 * -
 */

#ifndef CPROBABILITYDENSITYDISTRIBUTION_H
#define CPROBABILITYDENSITYDISTRIBUTION_H

// includes
#include "Distribution.h"
#include <iostream>
#include <functional>
#include <thread>


// typedef
typedef pair< PairDFType, PairDFType >SubIntLimitsType;
typedef vector< SubIntLimitsType >  VectorSubIntLimitsType;
//  { (targetValue,{ ((minthis,maxthis),(minother,maxother)) }) }
// e.g. [1].second[0].first.first: first integration limit of this distribution for the first sub integration step and the second target value
// e.g. [1].second[0].second.first: first integration limit of other distribution for the first sub integration step and the second target value
// no. of target values : PDD_DEFAULT_INTEGRATION_STEPS
// no. of integration limits for this and other: PDD_DEFAULT_SUBINTEGRATION_STEPS
typedef vector< PairDFType >  VectorPairDFType;
class ConvPlanElement
{
public:
    PairDFType  xLimits;
    PairDFType  yLimits;
    MapDFDFType::const_iterator xDistriIter;
    MapDFDFType::const_iterator yDistriIter;
};
typedef vector< ConvPlanElement >  VectorConvPlanElementType;
typedef vector< pair<CDigFloat, VectorConvPlanElementType> > ConvolutionPlanType;

typedef unordered_map<MapDFDFType::const_iterator,PairDFType, DistriIterHasher> UMapPDFType;




// macros
#define PDD_DEFAULT_INTEGRATION_STEPS 50
#define PDD_DEFAULT_SUBINTEGRATION_STEPS 10
#define PDD_NO_OF_THREADS 8

// enums
enum class ProbDistOp
{
    pdoUnknown = -1,
    pdoPlus,
    pdoFirst = pdoPlus,
    pdoMinus,
    pdoMult,
    pdoDiv,
    pdoCov,
    pdoLast
};

class 

#ifdef _WIN32
_WIN_DLL_API
#endif
CProbabilityDensityDistribution : public CDistribution
{

// needs access to protected members    
friend class CConvolutionThread;
friend CProbabilityDensityDistribution operator+(const CDigFloat& dfValue, CProbabilityDensityDistribution pdDistri);
friend CProbabilityDensityDistribution operator-(const CDigFloat& dfValue, CProbabilityDensityDistribution pdDistri);
friend CProbabilityDensityDistribution operator*(const CDigFloat& dfValue, CProbabilityDensityDistribution& pdDistri);
friend CProbabilityDensityDistribution operator/(const CDigFloat& dfValue, CProbabilityDensityDistribution& pdDistri);
friend CProbabilityDensityDistribution operator+(CProbabilityDensityDistribution pdOne, CProbabilityDensityDistribution pdOther);
friend CProbabilityDensityDistribution operator-(CProbabilityDensityDistribution pdOne, CProbabilityDensityDistribution pdOther);
friend CProbabilityDensityDistribution operator*(CProbabilityDensityDistribution pdOne, CProbabilityDensityDistribution pdOther);
friend CProbabilityDensityDistribution operator/(CProbabilityDensityDistribution pdOne, CProbabilityDensityDistribution pdOther);
friend CProbabilityDensityDistribution pow(CProbabilityDensityDistribution pdDistri, const int& dfValue, bool bUsePos);
friend CProbabilityDensityDistribution cut(CProbabilityDensityDistribution pdDistri, const CDigFloat& dfStartUser, const CDigFloat& dfEndUser);

public:
    
    ////////////////////////////////////////////
    // construction / destruction
    ////////////////////////////////////////////
    /**
     * Default constructor
     */
    CProbabilityDensityDistribution();

    /**
     * Copy constructor
     *
     * @param other CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution(const CProbabilityDensityDistribution& other);

    /**
     * Copy constructor
     *
     * @param other CDistribution
     */
    CProbabilityDensityDistribution(const CDistribution& other);

    /**
     * Destructor
     */
    ~CProbabilityDensityDistribution();

    ////////////////////////////////////////////
    // assignment operator
    ////////////////////////////////////////////
    /**
     * @brief Assignment operator
     *
     * @param other CProbabilityDensityDistribution
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution& operator=(const CProbabilityDensityDistribution& other);

    /**
     * @brief Assignment operator
     *
     * @param other CDistribution
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution& operator=(const CDistribution& other);
    
    ///////////////////////////////////
    // arithmetic operators
    ///////////////////////////////////
    /**
     * @brief summation assignment operator: results in a convolution with the sums of variables as the new \ref def-distri-variable "distribution variable" and the corresponding probability product as the new \ref def-distri-value "distribution values". 
     *
     * @param[in] other CProbabilityDensityDistribution
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution& operator += (CProbabilityDensityDistribution& other);
    /**
     * @brief summation operator: calls ::operator+= 
     *
     * @param[in] other CProbabilityDensityDistribution
     * @return CProbabilityDensityDistribution
     */
//     CProbabilityDensityDistribution operator+ (CProbabilityDensityDistribution& other);
    
    /**
     * @brief subtraction assignment operator: results in a convolution with the sums of variables as the new \ref def-distri-variable "distribution variable" and the corresponding probability product as the new \ref def-distri-value "distribution values".
     *
     * @param[in] other CProbabilityDensityDistribution
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution& operator -= (CProbabilityDensityDistribution& other);
    /**
     * @brief subtraction operator: calls ::operator-= 
     *
     * @param[in] other CProbabilityDensityDistribution
     * @return CProbabilityDensityDistribution
     */
//     CProbabilityDensityDistribution operator- (CProbabilityDensityDistribution& other);

    /**
     * @brief multiplication assignment operator: results in a convolution with the sums of variables as the new \ref def-distri-variable "distribution variable" and the corresponding probability product as the new \ref def-distri-value "distribution values".
     *
     * @param[in] other CProbabilityDensityDistribution
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution& operator*= (CProbabilityDensityDistribution& other);
    /**
     * @brief multiplication operator: calls ::operator*= 
     *
     * @param[in] other CProbabilityDensityDistribution
     * @return CProbabilityDensityDistribution
     */
//     CProbabilityDensityDistribution operator* (CProbabilityDensityDistribution& other);
    /**
     * @brief multiplication assignment operator: results in a convolution with the sums of variables as the new \ref def-distri-variable "distribution variable" and the corresponding probability product as the new \ref def-distri-value "distribution values".
     *
     * @param[in] other CProbabilityDensityDistribution
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution& operator/= (CProbabilityDensityDistribution& other);
    /**
     * @brief division operator: calls ::operator/= 
     *
     * @param[in] other CProbabilityDensityDistribution
     * @return CProbabilityDensityDistribution
     */
//     CProbabilityDensityDistribution operator/ (CProbabilityDensityDistribution& other);

    /**
     * @brief multiplication assingment operator with factor: is applied on \ref def-distri-variable "distribution variables"
     *
     * @param[in] Value CDigFloat factor
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution& operator*=(const CDigFloat& Value);

    /**
     * @brief division assingment operator with factor: is applied on \ref def-distri-variable "distribution variables"
     *
     * @param[in] Value CDigFloat divisor
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution& operator/=(const CDigFloat& Value);
    
    /**
     * @brief summation assingment operator with factor: is applied on \ref def-distri-variable "distribution variables"
     *
     * @param[in] Value CDigFloat summand
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution& operator+=(const CDigFloat& Value);
    
    /**
     * @brief subtraction assingment operator with factor: is applied on \ref def-distri-variable "distribution variables"
     *
     * @param[in] Value CDigFloat subtrahend
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution& operator-=(const CDigFloat& Value);
    /**
     * @brief multiplication operator with factor: is applied on \ref def-distri-variable "distribution variables"
     *
     * @param[in] Value CDigFloat factor
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution operator*(const CDigFloat& Value);

    /**
     * @brief division operator with factor: is applied on \ref def-distri-variable "distribution variables"
     *
     * @param[in] Value CDigFloat divisor
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution operator/(const CDigFloat& Value);
    
    /**
     * @brief summation operator with factor: is applied on \ref def-distri-variable "distribution variables"
     *
     * @param[in] Value CDigFloat summand
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution operator+(const CDigFloat& Value);
    
    /**
     * @brief subtraction operator with factor: is applied on \ref def-distri-variable "distribution variables"
     *
     * @param[in] Value CDigFloat subtrahend
     * @return CProbabilityDensityDistribution
     */
    CProbabilityDensityDistribution operator-(const CDigFloat& Value);
    
    ///////////////////////////////////
    // function on all distribution variables
    ///////////////////////////////////    
   /**
     * @brief shift is applied on \ref def-distri-variable "distribution variables"
     *
     * @param[in] Value CDigFloat shift added on all variables of distribution
     */
   void Shift(const CDigFloat& shift);
   /**
     * @brief scale is applied on \ref def-distri-variable "distribution variables"
     *
     * @param[in] Value CDigFloat scale is multiplies all variables of distribution
     */
    void Scale(const CDigFloat& scale);

    ////////////////////////////////////////////
    // comparison operator
    ////////////////////////////////////////////
    /**
     * @brief equality operator
     *
     * @param other CProbabilityDensityDistribution
     * @return bool
     */
    bool operator==(const CProbabilityDensityDistribution& other) const;

    /**
     * @todo inequality operator
     *
     * @param other CProbabilityDensityDistribution
     * @return bool
     */
    bool operator!=(const CProbabilityDensityDistribution& other) const;
    
    ////////////////////////////////////////////
    // distribution generation
    ////////////////////////////////////////////
    /**
     * @brief clears existing distri and generates a constant distribution for the given interval
     * 
     * @param[in] dfXMin CDigFloat minimal value of the interval
     * @param[in] dfXMax CDigFloat maximal value of the interval
     */
    void ConstDistribution(const CDigFloat& dfXMin, const CDigFloat& dfXMax);
    /**
     * @brief clears existing distri and generates a symmetrich triangulated distribution given by an interval
     * 
     * @param[in] dfXMin CDigFloat minimal value of the interval
     * @param[in] dfXMax CDigFloat maximal value of the interval
     */
    void TriangleDistribution(const CDigFloat& dfXMin, const CDigFloat& dfXMax);
    
    /**
     * @brief clears existing distri and generates a distribution according to function \f$f(x,\mu, \sigma) = \frac{1}{\sqrt{2\pi\sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}\f$ 
     * 
     * @param[in] dfMu CDigFloat expectation value
     * @param[in] dfSigma CDigFloat width of curve
     * @param[in] dfYResolution CDigFloat determines the resolution of  \f$f(x,\mu, \sigma) :
     *            the number of points used for one half of the symmetric distri is then:
     *            n = \frac{1}{\sqrt{2\pi\sigma^2}} \frac{1}{dfYResolution} 
     */
    void NormalDistribution(const CDigFloat& dfMu, const CDigFloat& dfSigma, const int nPoints = 50);
    
    /**
     * @brief clears existing distri and generates a distribution according to function \f$f(x,A, f) = A e^{fx}\f$ 
     * 
     * @param[in] dfAmplitude CDigFloat as amplitude factor
     * @param[in] dfExponentialFactor CDigFloat as exponential factor
     * @param[in] nPoint unsinged int determines the number of points
     */
    void ExponentialDistribution(const CDigFloat& dfA, const CDigFloat& dfF, const unsigned int nPoints = 50);
 
    ////////////////////////////////////////////
    // functions
    ////////////////////////////////////////////   
     /**
     * @brief returns (interpolated) value at the given variable and takes care that the distribution
     * is normalized: if not this will be done
     *
     * @param[in] variable CDigFloat variable to interpolate (linearily) the corresponding distribution value
     * @return CDigFloat the corresponding distribution value
     */
    CDigFloat DistriValue(const CDigFloat& variable);    
        
    /**
     * @brief calculates the nthOrder variance  
     *
     * @return CDigFloat variance < x-<x> >Â²
     */
    CDigFloat Variance();
            
   /**
     * @brief returns the distribution \ref def-distri-point "points" around the given variable
     *
     * @param[in] variable CDigFloat& variable to search surrounding \ref def-distri-point "points" for
     * @param[out] VariableLeft M_DFDF::iterator& iterator for left \ref def-distri-point "point" (see ::M_DFDF)
     * @param[out] VariableRight M_DFDF::iterator& iterator for right \ref def-distri-point "point" (see ::M_DFDF)
     */
    void GetInterval(const CDigFloat& variable, MapDFDFType::const_iterator& VariableLeft, MapDFDFType::const_iterator& VariableRight);   
    
    /**
     * @brief returns (interpolated) integral of the distribution between the user given limits
     *
     * @param[in] variableLeft CDigFloat for left limit of integral
     * @param[in] variableRight CDigFloat for right limit of integral
     * @param[in] nthOrder int for weighing the integral calculation with variable<SUP>+nthOrder</SUP> 
     * @return CDigFloat as
     */
    CDigFloat AbsIntegral(const CDigFloat& variableLeft, const CDigFloat& variableRight, int nthOrder = 0);     
    
    /**
     * @brief resets distribution 
     *
     */
    void  Reset();  
    
    /**
     * @brief calculates the integral of the absolute value of this distribution
     *
     * @return CDigFloat
     */
    CDigFloat AbsIntegral(const int& nthOrder =0);
        
    /**
     * @brief calculates the nthOrder mean variable weighted by distribution values
     *
     * @return CDigFloat nthOrder mean variable
     */
    CDigFloat Mean( int nthOrder = 1 );
        
    /**
     * @brief returns the actual integral (0th order) of the distribution
     *
     * @return CDigFloat 0th order integral
     */
    CDigFloat OrigIntegral();
   
    /**
     * @brief adds new distribution element if distribution is not already normalized (see ::_Normalize).
     *        In case of adding the last element the surrounding elements will be set to zero (... if not done)
     *        and the whole distribution will be normalized (see ::_Normalize).
     *
     * @param variable CDigFloat& distribution variable
     * @param value CDigFloat&
     * @param bLastElement bool if set --> ::_Normalize is called and no further element can be added
     * @return bool
     */
    bool Add(const CDigFloat& variable, const CDigFloat value, bool bLastElement = false); 
    /**
     * @brief normalize: divides by norm (integral over the distribution) 
     *
     * @param[in] bWithIntegralHistory bool consider error of integration calculation (default: do not consider)
     * @return bool
     */
    void Normalize(bool bWithIntegralError = false);     
    /**
     * @brief revert normalizatiion: multiplies by norm (integral over the distribution) 
     *
     * @param other CDistribution&
     * @return bool
     */
    void DeNormalize(); 
    
    ////////////////////////////////////////////
    // getter / setter
    //////////////////////////////////////////// 
    /**
     * @brief sets the number of resulting distribution from arithmetic operations with other distributions
     * 
     */
    void IntegrationSteps(int nSteps) { m_nIntegrationSteps = nSteps;}

    /**
     * @brief returns the number of resulting distribution from arithmetic operations with other distributions
     * 
     * @return int 
     * 
     */
    int IntegrationSteps() const { return m_nIntegrationSteps;}
    
    /**
     * @brief sets the number of integration steps for a single target value for a arithmetic operations with other distributions
     * 
     */
   void SubIntegrationSteps(int nSteps) { m_nSubIntegrationSteps = nSteps;}
    
    /**
     * @brief returns the number of integration steps for a single target value for a arithmetic operations with other distributions
     * 
     * @return int
     * 
     */
    int SubIntegrationSteps() const { return m_nSubIntegrationSteps;}
    
    CDigFloat& Offset(MapDFDFType::const_iterator it) const
    {
        LOGTRACE("DistributedNumber::CProbabilityDensityDistribution::Offset",string("called with ")+::Print(it));
        LOGTRACE("DistributedNumber::CProbabilityDensityDistribution::Offset",string("from ")+ Address2String(this));  
        LOGTRACE("DistributedNumber::CProbabilityDensityDistribution::Offset",string("offset ")+m_LinPars.at(it).first.RawPrint(10));   
        assert(m_LinPars.find(it) != m_LinPars.end()); 
        return const_cast<CDigFloat&>(m_LinPars.at(it).first);
        
    };
    CDigFloat& Slope(MapDFDFType::const_iterator it) const
    {
        LOGTRACE("DistributedNumber::CProbabilityDensityDistribution::Slope",string("called with ")+::Print(it));  
        LOGTRACE("DistributedNumber::CProbabilityDensityDistribution::Slope",string("from ")+ Address2String(this));  
        LOGTRACE("DistributedNumber::CProbabilityDensityDistribution::Slope",string("Slope ")+m_LinPars.at(it).second.RawPrint(10));    
        assert(m_LinPars.find(it) != m_LinPars.end()); 
        return const_cast<CDigFloat&>(m_LinPars.at(it).second);
        
    };
    
    /**
     * @brief returns the linear parameters for all intervalls as string
     * 
     * @return string
     * 
     */
    string PrintLinPars() const;
   
    virtual string PrintMetaInfo() const override;
    
protected:     
    /**
     * @brief initializes member
     *
     */
    void _Init();  
    void _SetPeripherialMember(const CProbabilityDensityDistribution& Other);
    
    
    /**
     * @brief returns the distribution range for a convolution with this distri and the other 
     * 
     * @param[in] other M_DFDF distribution
     * @param[in] Operation ProbDistOp the convolution operation (e.g. sum , subtration, ..)
     * @param[out] TargetRangeStart CDigFloat start variable of convolution result
     * @param[out] TargetRangeEnd CDigFloat end variable of convolution result
     * 
     */     
    void _GetRangeFromDistributionOperation(CProbabilityDensityDistribution& other, const ProbDistOp Operation, CDigFloat& TargetRangeStart, CDigFloat& TargetRangeEnd);
    
    ////////////////////////////////////////////////////////
    // functions for analytical calculation of parts of integrals
    ////////////////////////////////////////////////////////
    /**
    * @brief returns the distribution to a corresponding operation between two distributions
    * 
    * @return CProbabilityDensityDistribution resulting from corresponding operation
    *
    */     
    // without making a plan : prepares x-intervals and vector of target values
    CProbabilityDensityDistribution& _GeneralOperatorsFunctionAnalytical(CProbabilityDensityDistribution& other, const ProbDistOp Operation);
    
    
    void _Convolution4TargetValue(CProbabilityDensityDistribution& Other, const ProbDistOp Operation, const VectorPairDFType& vpdfXIntervals, const CDigFloat& dfTargetValue, CDigFloat& dfResult);
 
    void _Convolution4TargetValueThread(CProbabilityDensityDistribution* pOther, ProbDistOp *pOperation, VectorPairDFType* pvpdfXIntervals, vector<CDigFloat>* pvdfTargetValues, vector<CDigFloat>* pvdfResultPointer);
    
    /**
     * @brief set CProbabilityDensityDistribution::m_ConvolutionPlan which keeps the integration path for an arithmetic operation for all target values of 
     *   the resulting distribution
     * 
     * @param[in] Other CProbabilityDensityDistribution distribution the arithmetic operation is performed with this distri
     * @param[in] Operation ProbDistOp the arithmetic operation (e.g. sum , subtration, ..)
     * @param[out] vdfTargetValues vector of target values of type CDigFloat
     * @param[out] vpdfXIntervals vector of x-intervals of type pair<CDigFloat, CDigFloat>
     * 
     */  
    void _PrepareConvolution(CProbabilityDensityDistribution& Other, const ProbDistOp Operation, vector<CDigFloat>& vdfTargetValues, VectorPairDFType& vpdfXIntervals, CDigFloat& dfTargetValueSteps);
 
    /**
     * @brief sets the linear parameters (offset and slope) for each intervall of the distribution CProbabilityDensityDistribution::m_LinPars keeps these linear parameters
     * 
     */  
    void _SetLinPars();
 
    /**
     * @brief sets a single element of the linear parameters (offset and slope) : needed for external operators 
     * 
     */  
    void _ResetLinPars() {m_LinPars.clear();}

 
    /**
     * @brief sets a single element of the linear parameters (offset and slope) : needed for external operators 
     * 
     * @param[in] it MapDFDFType::const_iterator pointing to a interval of this distribution: is used as index for the linear parameters
     * @param[in] dfOffset CDigFloat as linear offset of the corresponding interval
     * @param[in] dfSlope CDigFloat as linear slope of the corresponding interval
     * 
     */  
    void _AddLinPar(MapDFDFType::const_iterator it, CDigFloat dfOffset, CDigFloat dfSlope) {m_LinPars[it] = PairDFType(dfOffset, dfSlope);}

    /**
     * @brief sets sub integration intervals in CProbabilityDensityDistribution::m_ConvolutionPlan for a single target value for a given of arithmetic operataion
     * 
     * @param[in] Operation ProbDistOp the arithmetic operation (e.g. sum , subtration, ..)
     * @param[in] dfActTargetValue CDigFloat given target value to derive integration intervals for
     * @param[in] Other CProbabilityDensityDistribution distribution the arithmetic operation is performed with this distri
     * for a given target value
     * 
     */  
     void _SetSubIntegrationIntervals4TargetValue(const ProbDistOp Operation, const CDigFloat& dfActTargetValue, CProbabilityDensityDistribution& Other);
   
    /**
     * @brief returns the variable interval of this distribution  (x-variable) on which the determination of the total and sub integration intervals for arithmetic operation bases.
     * 
     * @param[in] Operation ProbDistOp the arithmetic operation (e.g. sum , subtration, ..)
     * @param[out] vXIntervals interval(s) of x-variable
     * 
     */  
    void _GetXInterval4Operation(const ProbDistOp Operation, VectorPairDFType& vXIntervals);
    
    /**
     * @brief returns total integration interval of this distribution (x-variable) and the complementary intervals for
     *  the other distribution (y-variable) for arithmetic operation.
     * 
     * @param[in] Operation ProbDistOp the arithmetic operation (e.g. sum , subtration, ..)
     * @param[in] dfActTargetValue CDigFloat given target value to derive integration intervals for
     * @param[in] Other CProbabilityDensityDistribution distribution the arithmetic operation is performed with this distri
     * @param[in] vXIntervals interval(s) of x-variable
     * @param[out] TotalIntervals4TargetValue keeps total integration interval of this and other distributions with multiple offsets and slopes
     * 
     */
    void _GetTotalIntegrationInterval4TargetValue(const ProbDistOp& Operation, const CDigFloat& dfTargetValue, CProbabilityDensityDistribution& Other, const VectorPairDFType& vXIntervals, VectorSubIntLimitsType&  TotalIntervals4TargetValue);

    /**
     * @brief returns total sub-integration interval of this (x-variable) and other (y-variable) distribution  for arithmetic operation on the basis of the total integration interval. It divides the total intervals into intervals with unique slope and offset for this AND the other distribution
     * 
     * @param[in] Operation ProbDistOp the arithmetic operation (e.g. sum , subtration, ..)
     * @param[in] dfActTargetValue CDigFloat given target value to derive integration intervals for
     * @param[in] Other CProbabilityDensityDistribution distribution the arithmetic operation is performed with this distri
     * @param[out] SubIntervals4TargetValue sub-integration interval(s)
     * 
     */
    // optimized version: avoiding binary searches where ever possible
    void _GetSubIntegrationIntervalFromTotalIntegrationInterval4TargetValue(const ProbDistOp Operation, const CDigFloat& dfTargetValue, CProbabilityDensityDistribution& Other, const VectorSubIntLimitsType& TotalIntervals4TargetValue, VectorConvPlanElementType& SubIntervals4TargetValue);
  
    /**
     * @brief returns the complementary variable for a given operation, target value, and operation.
     * 
     * @param[in] Operation ProbDistOp the arithmetic operation (e.g. sum , subtration, ..)
     * @param[in] dfActTargetValue CDigFloat given target value to derive integration intervals for
     * @param[in] dfVariable CProbabilityDensityDistribution distribution the arithmetic operation is performed with this distri
     * @param[in] bVarIsYVar flag for variable type: true --> y variable (other distri)  
     * 
     */
    CDigFloat _GetComplementaryVariable(const ProbDistOp Operation, const CDigFloat& dfTargetValue, const CDigFloat& dfVariable, bool bVarIsYVar);
   CDigFloat _GetConvolutionIntegralAnalytical4Operation(CProbabilityDensityDistribution& Other, const ProbDistOp Operation, const CDigFloat& dfTargetValue, const ConvPlanElement& planEl);
      
    /**
     * @brief returns the value of the definite integral for convolution of addition: the results are optimized 
     *        providing good numerical accuracy minimizing the use of higher order differences
     * 
     * @param[in] Operation ProbDistOp the arithmetic operation (e.g. sum , subtration, ..)
     * @param[in] dfActTargetValue CDigFloat given target value to derive integration intervals for
     * @param[in] dfVariable CProbabilityDensityDistribution distribution the arithmetic operation is performed with this distri
     * @param[in] bVarIsYVar flag for variable type: true --> y variable (other distri)  
     * 
     */
   CDigFloat _Integral4TargetValue4Addition(const CDigFloat& dfTargetValue, CProbabilityDensityDistribution& Other, const ConvPlanElement& planEl);
   CDigFloat _Integral4TargetValue4Subtraction(const CDigFloat& dfTargetValue, CProbabilityDensityDistribution& Other, const ConvPlanElement& planEl);
   CDigFloat _Integral4TargetValue4Multiplication(const CDigFloat& dfTargetValue, CProbabilityDensityDistribution& Other, const ConvPlanElement& planEl);
   CDigFloat _Integral4TargetValue4Division(const CDigFloat& dfTargetValue, CProbabilityDensityDistribution& Other, const ConvPlanElement& planEl);
   
   
   ////////////////////////////////////////////////////////
   // member variables
   ////////////////////////////////////////////////////////
    
    bool bNormalized; 
    CDigFloat dfAbsIntegral;
    int m_nIntegrationSteps;
    int m_nSubIntegrationSteps;
    ConvolutionPlanType m_ConvolutionPlan;
    UMapPDFType m_LinPars;

};

   
////////////////////////////////////////////////////////
// external functions
////////////////////////////////////////////////////////
/**
  * @brief addition operator for CProbabilityDensityDistribution non-reference arguments
  * 
  * @param[in] pdOne CProbabilityDensityDistribution as numerator of x-values of new distri
  * @param[in] pdOther CProbabilityDensityDistributiondistribution which x-values are the denominator of the x-values of the new distri
  * @return CProbabilityDensityDistribution pdOne / pdOther
  * 
  */
CProbabilityDensityDistribution
#ifdef _WIN32
_WIN_DLL_API
#endif
operator+(CProbabilityDensityDistribution pdOne, CProbabilityDensityDistribution pdOther);

/**
  * @brief subtraction operator for CProbabilityDensityDistribution non-reference arguments
  * 
  * @param[in] pdOne CProbabilityDensityDistribution as numerator of x-values of new distri
  * @param[in] pdOther CProbabilityDensityDistributiondistribution which x-values are the denominator of the x-values of the new distri
  * @return CProbabilityDensityDistribution pdOne / pdOther
  * 
  */
CProbabilityDensityDistribution
#ifdef _WIN32
_WIN_DLL_API
#endif
operator-(CProbabilityDensityDistribution pdOne, CProbabilityDensityDistribution pdOther);

/**
  * @brief multiplication operator for CProbabilityDensityDistribution non-reference arguments
  * 
  * @param[in] pdOne CProbabilityDensityDistribution as numerator of x-values of new distri
  * @param[in] pdOther CProbabilityDensityDistributiondistribution which x-values are the denominator of the x-values of the new distri
  * @return CProbabilityDensityDistribution pdOne / pdOther
  * 
  */
CProbabilityDensityDistribution
#ifdef _WIN32
_WIN_DLL_API
#endif
operator*(CProbabilityDensityDistribution pdOne, CProbabilityDensityDistribution pdOther);

/**
  * @brief division operator for CProbabilityDensityDistribution non-reference arguments
  * 
  * @param[in] pdOne CProbabilityDensityDistribution as numerator of x-values of new distri
  * @param[in] pdOther CProbabilityDensityDistributiondistribution which x-values are the denominator of the x-values of the new distri
  * @return CProbabilityDensityDistribution pdOne / pdOther
  * 
  */
CProbabilityDensityDistribution
#ifdef _WIN32
_WIN_DLL_API
#endif
operator/(CProbabilityDensityDistribution pdOne, CProbabilityDensityDistribution pdOther);

/**
  * @brief returns a distri with x(new distri)=dfValue*x(pdDistri) keeping the probability values
  * 
  * @param[in] dfValue CDigFloat as factor of the x-values of the new distri
  * @param[in] CProbabilityDensityDistribution distribution which x-values are scaled by value
  * @return CProbabilityDensityDistribution with new x-values = dfValue * x(pdDistri)
  * 
  */
CProbabilityDensityDistribution
#ifdef _WIN32
_WIN_DLL_API
#endif
operator*(const CDigFloat& dfValue, CProbabilityDensityDistribution& pdDistri);

/**
  * @brief returns a distri with x(new distri)=dfValue/x(pdDistri) keeping the probability values
  * 
  * @param[in] dfValue CDigFloat as numerator of x-values of new distri
  * @param[in] CProbabilityDensityDistribution distribution which x-values are the denominator of the x-values of the new distri
  * @return CProbabilityDensityDistribution with new x-values = dfValue / x(pdDistri)
  * 
  */
CProbabilityDensityDistribution
#ifdef _WIN32
_WIN_DLL_API
#endif
operator/(const CDigFloat& dfValue, CProbabilityDensityDistribution& pdDistri);

/**
  * @brief returns a distri with x(new distri)=dfValue+x(pdDistri) keeping the probability values
  * 
  * @param[in] dfValue CDigFloat as added to x-values of new distri
  * @param[in] CProbabilityDensityDistribution distribution which x-values are increased by the value
  * @return CProbabilityDensityDistribution with new x-values = dfValue + x(pdDistri)
  * 
  */
CProbabilityDensityDistribution
#ifdef _WIN32
_WIN_DLL_API
#endif
operator+(const CDigFloat& dfValue, CProbabilityDensityDistribution pdDistri);

/**
  * @brief returns a distri with x(new distri)=dfValue-x(pdDistri) keeping the probability values
  * 
  * @param[in] dfValue CDigFloat as subtrahend of x-values of new distri
  * @param[in] CProbabilityDensityDistribution distribution which x-values are the subtractor of the x-values of the new distri
  * @return CProbabilityDensityDistribution with new x-values = dfValue - x(pdDistri)
  * 
  */
CProbabilityDensityDistribution
#ifdef _WIN32
_WIN_DLL_API
#endif
operator-(const CDigFloat& dfValue, CProbabilityDensityDistribution pdDistri);

/**
  * @brief returns a distri with x(new distri)=x(pdDistri)^nExponent keeping the probability values
  * 
  * @param[in] nExponent int as exponent of x-values of new distri
  * @param[in] CProbabilityDensityDistribution distribution which x-values are the base of the x-values of the new distri
  * @param[in] bUsePos bool flag determining to use 
  * @return CProbabilityDensityDistribution with new x-values = x(pdDistri)^dfValue
  * 
  */
CProbabilityDensityDistribution
#ifdef _WIN32
_WIN_DLL_API
#endif
pow(CProbabilityDensityDistribution pdDistri, const int& nExponent, bool bUsePos = true);

/**
  * @brief returns a distri with a new user given interval. This new distri is normalized to the new interval.
  *        In case the user given interval does not overlap the returned distribution is not initialized
  * 
  * @param[in] pdDistri  CProbabilityDensityDistribution distri to cut interval from
  * @param[in] dfStartUser CDigFloat start value of the user given interval
  * @param[in] dfEndUser CDigFloat end value of the user given interval
  * @return CProbabilityDensityDistribution with new interval
  * 
  */
CProbabilityDensityDistribution
#ifdef _WIN32
_WIN_DLL_API
#endif
cut(CProbabilityDensityDistribution pdDistri, const CDigFloat& dfStartUser, const CDigFloat& dfEndUser);
/**
  * @brief returns a distri from the operation - of two distribtuions (no reference)
  * 
  * @param[in] pdOne  CProbabilityDensityDistribution as subtrahend 
  * @param[in] pdOther CProbabilityDensityDistribution as subtractor
  * @return CProbabilityDensityDistribution as difference of pdOne - pdOther
  * 
  */
// CProbabilityDensityDistribution
// #ifdef _WIN32
// _WIN_DLL_API
// #endif
// operator+(CProbabilityDensityDistribution pdOne, CProbabilityDensityDistribution pdOther);

string
#ifdef _WIN32
_WIN_DLL_API
#endif
GetProbDistOpAsString( ProbDistOp op );


   
////////////////////////////////////////////////////////
// thread class for convolution
////////////////////////////////////////////////////////
#endif // CPROBABILITYDENSITYDISTRIBUTION_H
